# ‚ö° –ë—ã—Å—Ç—Ä–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: –ö—Ä–µ–≤–µ—Ç–∫–∏ –æ—Å—Ç–∞—é—Ç—Å—è –≤ –Ω–∞–ª–∏—á–∏–∏

**–ü—Ä–æ–±–ª–µ–º–∞:** –ü–æ—Å–ª–µ –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ "–î–æ—Å—Ä–æ—á–Ω–æ–µ –æ–∫–æ–Ω—á–∞–Ω–∏–µ" –∫—Ä–µ–≤–µ—Ç–∫–∏ –æ—Å—Ç–∞—é—Ç—Å—è –∑–µ–ª–µ–Ω—ã–º–∏ (–≤ –Ω–∞–ª–∏—á–∏–∏)

## üöÄ –ë—ã—Å—Ç—Ä–æ–µ —Ä–µ—à–µ–Ω–∏–µ (5 –º–∏–Ω—É—Ç)

### 1Ô∏è‚É£ –û—Ç–∫—Ä–æ–π—Ç–µ Supabase

üîó [supabase.com](https://supabase.com) ‚Üí –í–∞—à –ø—Ä–æ–µ–∫—Ç **Grocery** ‚Üí **SQL Editor**

### 2Ô∏è‚É£ –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ SQL

–ù–∞–∂–º–∏—Ç–µ **+ New Query**, –≤—Å—Ç–∞–≤—å—Ç–µ —ç—Ç–æ—Ç –∫–æ–¥ –∏ –Ω–∞–∂–º–∏—Ç–µ **Run**:

```sql
-- –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ calculate_product_type_status
-- –¢–µ–ø–µ—Ä—å –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ä–æ—á–Ω–æ–µ –æ–∫–æ–Ω—á–∞–Ω–∏–µ (quantity=-1) –ü–ï–†–ï–î –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ–º –ø—Ä–∞–≤–∏–ª–∞ 2 –¥–Ω–µ–π

CREATE OR REPLACE FUNCTION calculate_product_type_status(
  p_family_id INTEGER,
  p_product_type VARCHAR(255)
) RETURNS VARCHAR(20) AS $$
DECLARE
  v_status VARCHAR(20) := 'calculating';
  v_has_recent_purchase BOOLEAN := false;
  v_product_record RECORD;
  v_history_count INTEGER;
  v_avg_days DECIMAL;
  v_last_purchase_date DATE;
  v_predicted_end DATE;
  v_days_since_purchase INTEGER;
  v_days_until_end INTEGER;
  v_today DATE;
  v_last_history_quantity DECIMAL;
  v_is_early_depletion BOOLEAN := false;
BEGIN
  v_today := CURRENT_DATE;
  
  -- –ü–†–ò–û–†–ò–¢–ï–¢ 1: –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ä–æ—á–Ω–æ–µ –æ–∫–æ–Ω—á–∞–Ω–∏–µ (quantity=-1)
  FOR v_product_record IN
    SELECT p.id, p.last_purchase
    FROM products p
    WHERE p.family_id = p_family_id 
      AND p.product_type = p_product_type
      AND p.last_purchase IS NOT NULL
  LOOP
    SELECT ph.quantity INTO v_last_history_quantity
    FROM product_history ph
    WHERE ph.product_id = v_product_record.id
      AND ph.family_id = p_family_id
    ORDER BY ph.date DESC, ph.id DESC
    LIMIT 1;
    
    IF v_last_history_quantity = -1 THEN
      v_is_early_depletion := true;
      EXIT;
    END IF;
  END LOOP;
  
  IF v_is_early_depletion THEN
    RETURN 'ending-soon';
  END IF;
  
  -- –ü–†–ò–û–†–ò–¢–ï–¢ 2: –ü—Ä–∞–≤–∏–ª–æ 2 –¥–Ω–µ–π (—Ç–æ–ª—å–∫–æ –¥–ª—è –æ–±—ã—á–Ω—ã—Ö –ø–æ–∫—É–ø–æ–∫)
  FOR v_product_record IN
    SELECT id, last_purchase
    FROM products
    WHERE family_id = p_family_id 
      AND product_type = p_product_type
      AND last_purchase IS NOT NULL
  LOOP
    v_days_since_purchase := v_today - v_product_record.last_purchase;
    
    IF v_days_since_purchase < 2 THEN
      SELECT ph.quantity INTO v_last_history_quantity
      FROM product_history ph
      WHERE ph.product_id = v_product_record.id
        AND ph.family_id = p_family_id
      ORDER BY ph.date DESC, ph.id DESC
      LIMIT 1;
      
      IF v_last_history_quantity != -1 THEN
        v_has_recent_purchase := true;
        EXIT;
      END IF;
    END IF;
  END LOOP;
  
  IF v_has_recent_purchase THEN
    RETURN 'ok';
  END IF;
  
  -- –ü–†–ò–û–†–ò–¢–ï–¢ 3: –û–±—ã—á–Ω–∞—è –ª–æ–≥–∏–∫–∞
  SELECT COUNT(*) INTO v_history_count
  FROM product_history ph
  JOIN products p ON ph.product_id = p.id
  WHERE p.family_id = p_family_id 
    AND p.product_type = p_product_type;
  
  IF v_history_count < 2 THEN
    RETURN 'calculating';
  END IF;
  
  WITH purchase_intervals AS (
    SELECT 
      date,
      LAG(date) OVER (ORDER BY date) AS prev_date
    FROM product_history ph
    JOIN products p ON ph.product_id = p.id
    WHERE p.family_id = p_family_id 
      AND p.product_type = p_product_type
  )
  SELECT AVG(date - prev_date)::DECIMAL
  INTO v_avg_days
  FROM purchase_intervals
  WHERE prev_date IS NOT NULL AND (date - prev_date) > 0;
  
  IF v_avg_days IS NULL THEN
    RETURN 'calculating';
  END IF;
  
  SELECT MAX(last_purchase) INTO v_last_purchase_date
  FROM products
  WHERE family_id = p_family_id 
    AND product_type = p_product_type;
  
  IF v_last_purchase_date IS NULL THEN
    RETURN 'calculating';
  END IF;
  
  v_predicted_end := v_last_purchase_date + v_avg_days::INTEGER;
  v_days_until_end := v_predicted_end - v_today;
  
  IF v_days_until_end <= 2 THEN
    RETURN 'ending-soon';
  ELSE
    RETURN 'ok';
  END IF;
END;
$$ LANGUAGE plpgsql;
```

### 3Ô∏è‚É£ –ü–µ—Ä–µ—Å—á–∏—Ç–∞–π—Ç–µ –∫—ç—à

–í—ã–ø–æ–ª–Ω–∏—Ç–µ –µ—â–µ –æ–¥–∏–Ω –∑–∞–ø—Ä–æ—Å (–∑–∞–º–µ–Ω–∏—Ç–µ `1` –Ω–∞ ID –≤–∞—à–µ–π —Å–µ–º—å–∏, –µ—Å–ª–∏ –¥—Ä—É–≥–æ–π):

```sql
SELECT recalculate_product_type_stats(1);
```

### 4Ô∏è‚É£ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏

1. –û–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É (F5)
2. –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –æ—Ä–∞–Ω–∂–µ–≤—É—é –∫–Ω–æ–ø–∫—É —É –∫—Ä–µ–≤–µ—Ç–æ–∫
3. ‚úÖ –ö—Ä–µ–≤–µ—Ç–∫–∏ –¥–æ–ª–∂–Ω—ã —Å—Ç–∞—Ç—å –æ—Ä–∞–Ω–∂–µ–≤—ã–º–∏ "–ó–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è"

---

## üéØ –ß—Ç–æ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ

**–ë—ã–ª–æ:**
```
–ù–∞–∂–∞—Ç—å "–î–æ—Å—Ä–æ—á–Ω–æ–µ –æ–∫–æ–Ω—á–∞–Ω–∏–µ" ‚Üí ‚ùå –ö—Ä–µ–≤–µ—Ç–∫–∏ –æ—Å—Ç–∞—é—Ç—Å—è –∑–µ–ª–µ–Ω—ã–º–∏
```

**–°—Ç–∞–ª–æ:**
```
–ù–∞–∂–∞—Ç—å "–î–æ—Å—Ä–æ—á–Ω–æ–µ –æ–∫–æ–Ω—á–∞–Ω–∏–µ" ‚Üí ‚úÖ –ö—Ä–µ–≤–µ—Ç–∫–∏ —Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è –æ—Ä–∞–Ω–∂–µ–≤—ã–º–∏
```

---

## üìö –ü–æ–¥—Ä–æ–±–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è

- `–ò–°–ü–†–ê–í–õ–ï–ù–ò–ï_–î–û–°–†–û–ß–ù–û–ì–û_–û–ö–û–ù–ß–ê–ù–ò–Ø_–ö–≠–®.md` - –ø–æ–ª–Ω–∞—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –Ω–∞ —Ä—É—Å—Å–∫–æ–º
- `FIX_EARLY_DEPLETION_CACHE_STATUS.md` - full English documentation
- `migration_fix_early_depletion_in_cache.sql` - —Ç–æ—Ç –∂–µ SQL –∫–æ–¥ –æ—Ç–¥–µ–ª—å–Ω—ã–º —Ñ–∞–π–ª–æ–º





